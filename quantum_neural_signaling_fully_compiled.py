# -*- coding: utf-8 -*-
"""Quantum Neural Signaling Fully Compiled

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17grBqwTtxtgPH7jjdE2py4gzK_-zzGlT

Signular Value Decomposition to Determine K/D Migration

a. Creating Contact Map/Crystal Structure of Silk-Kinesin Multimer
"""

!pip install biopython matplotlib mdtraj

import numpy as np
from Bio.PDB import PDBParser
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.spatial.distance import cdist

def extract_coordinates(pdb_file_path):
    coordinates = []
    parser = PDBParser(QUIET=True)
    structure = parser.get_structure('protein', pdb_file_path)
    for model in structure:
        for chain in model:
            for residue in chain:
                for atom in residue:
                    coordinates.append(atom.get_coord())
    return np.array(coordinates)

def calculate_contact_map(coordinates, cutoff=8.0):
    distance_matrix = cdist(coordinates, coordinates)
    contact_map = (distance_matrix < cutoff).astype(int)
    np.fill_diagonal(contact_map, 0)
    return contact_map


def display_contact_map_3D(coordinates, coordinates_2, contact_map, contact_map_2):
    fig=plt.figure()
    ax=fig.add_subplot(111, projection='3d')
    residue_indices=np.arange(len(coordinates))
    x_contacts, y_contacts, z_contacts=[],[],[]
    for i in range(len(contact_map)):
        for j in range(len(contact_map)):
            if contact_map[i,j]==1:
                x_contacts.append(coordinates[i][0])
                y_contacts.append(coordinates[i][1])
                z_contacts.append(coordinates[i][2])
    x2, y2, z2=[],[],[]
    for i in range (len(contact_map_2)):
        for j in range (len(contact_map_2)):
            if contact_map_2[i,j]==1:
                x2.append(coordinates_2[i][0])
                y2.append(coordinates_2[i][1])
                z2.append(coordinates_2[i][2])
    ax.scatter(x_contacts, y_contacts, z_contacts, c='b',marker='o',s=20)
    ax.scatter(x2, y2, z2, c='r', marker='^', s=20)
    plt.show()

if __name__=="__main__":
    pdb_file_path_1='/content/5vos (1).pdb'
    pdb_file_path_2='/content/2onv (1).pdb'
    coords_protein_1=extract_coordinates(pdb_file_path_1)
    coords_protein_2=extract_coordinates(pdb_file_path_2)
    contact_map_1=calculate_contact_map(coords_protein_1, cutoff=8.0)
    contact_map_2=calculate_contact_map(coords_protein_2, cutoff=8.0)
    display_contact_map_3D(coords_protein_1, coords_protein_2, contact_map_1, contact_map_2)

combined_contact_map = np.block([
    [contact_map_1, np.zeros((contact_map_1.shape[0], contact_map_2.shape[1]))],
    [np.zeros((contact_map_2.shape[0], contact_map_1.shape[1])), contact_map_2]
])

combined_contact_map = combined_contact_map.reshape(combined_contact_map.shape[0], -1)

coords = []
for i in range(combined_contact_map.shape[0]):
    for j in range(combined_contact_map.shape[1]):
        if combined_contact_map[i, j] == 1:
            coord_i = coords_protein_1[i] if i < coords_protein_1.shape[0] else coords_protein_2[i - coords_protein_1.shape[0]]
            coord_j = coords_protein_1[j] if j < coords_protein_1.shape[0] else coords_protein_2[j - coords_protein_1.shape[0]]
            coords.append((coord_i, coord_j))
coords_array = np.array(coords)
print(coords_array)

with open('protein_structure.pdb', 'w') as pdb_file:
    for i, (coord1, coord2) in enumerate(coords_array):
        res_number=i+1
        residue_name = "GLY"
        chain_id = "A"
        pdb_file.write(f"ATOM  {res_number:5d}  CA  {residue_name} {chain_id}{res_number:4d}    "
                       f"{coord1[0]:8.3f}{coord1[1]:8.3f}{coord1[2]:8.3f}  1.00 20.00           C\n")
        res_number += 1
        pdb_file.write(f"ATOM  {res_number:5d}  CA  {residue_name} {chain_id}{res_number:4d}    "
                       f"{coord2[0]:8.3f}{coord2[1]:8.3f}{coord2[2]:8.3f}  1.00 20.00           C\n")
    pdb_file.write("END\n")

!pip install biopandas

import pandas as pd
from biopandas.pdb import PandasPdb
import plotly.express as px
import plotly.graph_objects as go

def display_crystal_structure(coordinates, opacity=0.2):
    x_coords, y_coords, z_coords = [], [], []
    for coord1, coord2 in coordinates:
        x_coords.append(coord1[0])
        y_coords.append(coord1[1])
        z_coords.append(coord1[2])

        x_coords.append(coord2[0])
        y_coords.append(coord2[1])
        z_coords.append(coord2[2])

    fig = go.Figure(data=[go.Scatter3d(
        x=x_coords,
        y=y_coords,
z=z_coords,
mode='lines+markers',
    line=dict(color='blue', width=1),
    opacity=opacity,
    marker=dict(size=3, color=(0, 0, 255, 128))
)])
    fig.show()


display_crystal_structure(coords_array)

"""b. Determine Tunneling Probability"""

import numpy as np
from scipy.optimize import minimize

def potential_energy(coords_array):
    k=1.0
    distance=np.linalg.norm(coords_array[0]-coords_array[1])
    return 0.5*k*(distance-equilibrium_distance)**2

def tunneling_probability(energy_barrier):
    gamma=0.15
    return np.exp(-2*gamma*energy_barrier)

atomic_coordinates=np.array([
    [1.346, -0.647, 35.267],
    [5.448, 0.358, 1.477]
])

equilibrium_distance = 8.0

energy=potential_energy(coords_array)
probability=tunneling_probability(energy)
print(f"Energy: {energy}")
print(f"Tunneling Probability: {probability}")

"""c. Calculate quantum yield (fluorescence)"""

def dihedral_angle(coords, index1, index2, index3, index4):
    A=coords[index1]
    B=coords[index2]
    C=coords[index3]
    D=coords[index4]
    BA=A-B
    BC=C-B
    CD=D-C
    N1=np.cross(BA,BC)
    N2=np.cross(BC,CD)
    N1 /= np.linalg.norm(N1)
    N2 /= np.linalg.norm(N2)
    angle=np.arctan2(np.dot(N2.T, N1), np.dot(np.cross(N1,N2).T, BC/np.linalg.norm(BC)))
    return angle

import numpy as np
import itertools

def dihedral_angle(A, B, C, D):
    BA=A-B
    BC=C-B
    CD=D-C
    N1=np.cross(BA,BC)
    N2=np.cross(BC,CD)

    print("N1:", N1)
    print("N2:", N2)

    if np.linalg.norm(N1) == 0 or np.linalg.norm(N2) == 0:
        return 0.0

    N1 /= np.linalg.norm(N1)
    N2 /= np.linalg.norm(N2)

    dot_product = np.dot(N2.T, N1)
    dot_product = np.clip(dot_product, -1.0, 1.0)

    print("Dot product:", dot_product)

    angle=np.arctan2(dot_product, np.dot(np.cross(N1,N2).T, BC/np.linalg.norm(BC)))
    return angle

def calculate_fluorescence(tau_planar, angles):
    k_non_radiative=np.sum(np.cos(angles)**2)
    QY=tau_planar/(tau_planar+k_non_radiative)
    return QY

tau_planar=0.2421
coords = np.array(coords)


num_calculations = 5

for _ in range(num_calculations):
    random_indices = np.random.choice(coords.shape[0], 4, replace=False)
    A = coords[random_indices[0]]
    B = coords[random_indices[1]]
    C = coords[random_indices[2]]
    D = coords[random_indices[3]]

    angle_rad = dihedral_angle(A, B, C, D)
    fluorescence = calculate_fluorescence(tau_planar, np.array([angle_rad]))

    angle_degrees = np.degrees(angle_rad)


    print(f"Calculated Dihedral Angle (in degrees):\n {angle_degrees}")
    print(f"Estimated QY: {fluorescence:.4f}\n")

"""c. Calculate Matrix Rearrangement (Information Theory)"""

def gaussian_density_matrix(coordinates, sigma=1.0):
    N=coordinates.shape[0]
    density_matrix=np.zeros((N,N))
    for i in range(N):
        for j in range(N):
            distance=np.linalg.norm(coordinates[i]-coordinates[j])
            density_matrix[i,j]=np.exp(-distance**2/(2*sigma**2))
        density_matrix /= np.sum(density_matrix)
    return density_matrix

if __name__=="__main__":
    atomic_coordinates=coords_array
    density_matrix=gaussian_density_matrix(atomic_coordinates, sigma=1.0)

def shannon_entropy(density_matrix):
    eigenvalues=np.linalg.eigvals(density_matrix)
    eigenvalues=eigenvalues[eigenvalues>0]
    entropy=-np.sum(eigenvalues*np.log2(eigenvalues))
    return entropy

entropy_value=shannon_entropy(density_matrix)
print("Shannon Entropy:", entropy_value)

def visualize_iteration(atomic_coordinates, density_matrix):
    """Visualizes an iteration of the density matrix as a 3D scatter plot."""
    fig = plt.figure()
    ax = fig.add_subplot(projection='3d')

    x = atomic_coordinates[:, 0]
    y = atomic_coordinates[:, 1]
    if atomic_coordinates.shape[1] > 2:
        z = atomic_coordinates[:, 2]
    else:
        z = np.zeros_like(x)
    sizes = np.mean(np.diag(density_matrix)) * 50

    ax.scatter(x, y, z, s=sizes)

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    plt.title("Crystal Structure Visualization")

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')
    plt.title("Crystal Structure Visualization")
    plt.show()

def generate_iterations(density_matrix, iterations=10, perturbation=entropy_value):
    iterations_results=[density_matrix.copy()]

    current_entropy=shannon_entropy(iterations_results[0])
    print(f"Iteration 1, Shannon Entropy: {current_entropy}")
    for i in range(iterations-1):
        perturbation_matrix=np.random.uniform(-perturbation, perturbation, size=density_matrix.shape)
        new_density_matrix=iterations_results[-1]+perturbation_matrix
        new_density_matrix=(new_density_matrix+new_density_matrix.T)/2
        new_density_matrix/=np.trace(new_density_matrix)
        iterations_results.append(new_density_matrix)

        current_entropy=shannon_entropy(iterations_results[-1])
        print(f"Iteration {i+2}, Shannon Entropy: {current_entropy}")
    return iterations_results

density_matrix_initial=density_matrix
iterations=generate_iterations(density_matrix_initial, iterations=5, perturbation=entropy_value)
for idx, density_matrix in enumerate(iterations):
    print(f"Iteration {idx}:")
    print(density_matrix)

for idx, density_matrix in enumerate(iterations):
    print(f"Iteration {idx}:")
    print(density_matrix)
    visualize_iteration(atomic_coordinates, density_matrix)

"""d. Kinetic Monte Carlo Model"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def create_assymetric_fractal_grid(size, iterations, fractal_dimension):
    grid=np.ones((size,size), dtype=int)
    def remove_pattern(x, y, s):
        if s==1:
            return
        step=s//3
        for i in range (3):
            for j in range (3):
                if (i,j)!=(1,1) and np.random.rand() < fractal_dimension:
                    remove_pattern(x+i*step, y+j*step, step)
    remove_pattern(0,0,size)
    return grid

def intitalize_exciton_positions(grid, num_excitons):
    indices=np.nonzero(grid)
    positions=np.vstack((indices[0], indices[1])).T
    np.random.shuffle(positions)
    return positions[:num_excitons]

def kinetic_monte_carlo_step(grid, excitons, diffusion_rate):
    new_exciton_positions=[]
    for exc in excitons:
        x,y=exc
        possible_moves=[(x-1,y),(x+1,y),(x,y-1),(x,y+1)]
        np.random.shuffle(possible_moves)
        for nx, ny in possible_moves:
            if (0<=nx<grid.shape[0] and 0<=ny<grid.shape[1] and grid[nx,ny]==1):
                if np.random.rand()<diffusion_rate:
                    new_exciton_positions.append((nx,ny))
                    break
        else:
            new_exciton_positions.append((x,y))
    return new_exciton_positions

def perturb_fractal(grid, perturbation_probability):
    for i in range(grid.shape[0]):
        for j in range(grid.shape[1]):
            if np.random.rand() < perturbation_probability:
                grid[i, j] = 1 - grid[i, j]
    return grid

def plot_grid(grid, excitons):
    plt.imshow(grid, cmap='gray', interpolation='nearest')
    if excitons:
        exciton_x, exciton_y=zip(*exciton_positions)
        plt.scatter(exciton_y, exciton_x, c='red', s=10)
    plt.show()

def plot_excitons(excitons):
    exciton_x, exciton_y=zip(*excitons)
    plt.scatter(exciton_y, exciton_x, c='red', s=10)
    plt.show()

grid_size=1000
iterations=1894
num_excitons=10000
diffusion_rate=0.126
fractal_dimension=0.5215535081333474
perturbation_probability = 0.179514094112


grid = create_assymetric_fractal_grid(grid_size, iterations,fractal_dimension)
grid = perturb_fractal(grid, perturbation_probability)

exciton_positions=intitalize_exciton_positions(grid, num_excitons)

num_steps=100
for step in range (num_steps):
    exciton_positions=kinetic_monte_carlo_step(grid, exciton_positions, diffusion_rate)
    if step % 1==0:
        plot_excitons(exciton_positions)
    else:
        plot_grid(grid, exciton_positions)

plt.show()

exciton_x, exciton_y = zip(*exciton_positions)
sns.kdeplot(x=exciton_x, y=exciton_y, cmap="Reds", shade=True, bw_adjust=.5)
plt.show()

"""e. Determination of quantum entanglement in excitons"""

def make_hermitian(matrix):
    return (matrix + matrix.conjugate().transpose()) / 2

hermitian_matrix = make_hermitian(density_matrix)
print(hermitian_matrix)

import pandas as pd

exciton_x, exciton_y = zip(*exciton_positions)
df = pd.DataFrame({'x': exciton_x, 'y': exciton_y})

df.to_csv('exciton_density.csv', index=False)
from google.colab import files
files.download('exciton_density.csv')

!pip install scipy
from scipy.linalg import logm

def calculate_reduced_density_matrix(hermitian_matrix, subsystem_indices):
    reduced_density_matrix = density_matrix.copy()
    for index in sorted(subsystem_indices, reverse=True):
        reduced_density_matrix = np.sum(reduced_density_matrix, axis=index, keepdims=True)
    return reduced_density_matrix

def calculate_entropy(hermitian_matrix):
    eigenvalues=np.linalg.eigvalsh(hermitian_matrix)
    filtered_eigenvalues=eigenvalues[eigenvalues > 0]
    if filtered_eigenvalues.size==0:
        filtered_eigenvalues = np.array([1e-10])
    log_eigenvalues=np.log(filtered_eigenvalues)
    entropy=-np.sum(filtered_eigenvalues*log_eigenvalues)
    return entropy

def calculate_tangle(hermitian_matrix):
    tangle=np.trace(hermitian_matrix)-1
    return tangle

density_data=np.loadtxt('/content/exciton_density.csv', delimiter=',', skiprows=1)
print(density_data)
print("Original shape:", density_data.shape)

new_matrix=density_data.reshape((4,5000))
print(new_matrix.shape)

def make_square_with_padding(matrix):
    rows, cols = matrix.shape
    size = max(rows, cols)
    square_matrix = np.zeros((size, size))
    square_matrix[:rows, :cols] = matrix
    return square_matrix

square_matrix = make_square_with_padding(new_matrix)
print(square_matrix.shape)

def normalize_matrix(hermitian_matrix):
    frobenius_norm=np.linalg.norm(hermitian_matrix, 'fro')
    return hermitian_matrix/frobenius_norm

def make_positive_semi_definite(hermitian_matrix):
    eigenvalues, eigenvectors=np.linalg.eig(hermitian_matrix)
    positive_eigenvalues=np.maximum(eigenvalues,0)
    return eigenvectors@np.diag(positive_eigenvalues)@eigenvectors.conj().T

def set_trace_to_one(hermitian_matrix):
    current_trace=np.trace(hermitian_matrix)
    return hermitian_matrix/current_trace

hermitian_matrix=normalize_matrix(hermitian_matrix)
hermitian_matrix=make_positive_semi_definite(hermitian_matrix)
hermitian_matrix=set_trace_to_one(hermitian_matrix)

tangle_value=calculate_tangle(hermitian_matrix)
print("Tangle Value:", tangle_value)
entropy_value=calculate_entropy(hermitian_matrix)
print("Entropy Value:", entropy_value)